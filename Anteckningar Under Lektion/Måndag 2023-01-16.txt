Skapa en class library för att skapa en DataAccess som gör våran koppling till MongoDb. Anledningen till en DataAccess som class library är för att kunna
ge kopplingen till flera applikationer. I vår DataAccess så använder vi oss av Nuget Paketet MongoDb.Driver, men BARA i DataAccesen.

När vi skapar en interface som ex kallas IRepository<T> och skapar metoder där inne, när man tillsätter parametrar i dessa metoder så vill man använda
object för att object kan ta in vad som helst. De metoderna kan vi sedan göra CRUD operationer av i en klass och använda oss av det i andra applikationer.

När vi använder oss av interfacet i en klass som sitter i DataAccess, den klassen hanterar all våran kommunikation till MongoDb.

Om vi ska skapa collections/tabeller, så vill man skapa en ny klass för varje collection och ex säga i början av koden 
"private readonly IMongoCollection<Person> _collection;"

När vi använder oss av IRepository<T>, så kan vi även använda det för att byta databas från MongoDb till SQL utan att påverka koden. Vi kan även skapa
en till interface som ska skapa en samling av objekt med namnet ex IAggregate<T>

Om man ska koppla mot en cloud med mongoDb, så vill vi skriva ex "var settings = MongoClientSettings.FromConnectionString("Här Ligger connectionString")";
Eller så kopierar du texten Atlas genererar. 

För Dependecy Injection, så vill du installera två nuget paket till dependencies och den första heter Microsoft.Extensions.DependencyInjection.
Den andra heter Mincrosoft.Extensions.Hosting.

När vi jobbar med Dependency Injection så kommer vi att börja jobba med App.xaml.cs som vi gjorde i MvvM och ta bort StartUpUri från App.xaml.

För att få upp mainwindow så säger vi i App konstruktorn services.AddScoped<MainWindow>(); För att starta upp MainWindow.
Hur detta fungerar är för att services i det här fallet som ligger i AppHost = Host.CreateDefaultBuilder().ConfigureServices((hostContext, services) =>
{
	services.AddScoped<IRepository<Person>, PeopleManager>();
	services.AddScoped<MainWindow>();
}).Build();

är det som innehåller "new". Sedan för att starta upp fönstret måste vi override igen OnStartUp.

protected override async void OnStartup(StartUpEventArgs e)
{
	await AppHost.StartAsync();

	var mainWindow = AppHost!.Services.GetRequiredService<MainWindow>();
	mainWindow.Show();
	base.OnStartup(e);
}

protected override async void OnExit(ExitEventArgs e)
{
	await AppHost.StopAsync():
	base.OnExit(e);
}
Notera att vi returnerar en void på en async metod, detta är eftersom vi inte kan göra mycket åt det. Det är sällan man får göra så men i sådana tillfällen
är det okej.

OnExit måste vi ha för att se till att Apphost inte ligger och kör medan programmet är avstängt.